/*
 * generated by Xtext 2.38.0
 */
package org.xtext.robotdsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.robotdsl.robotDsl.Model
import org.xtext.robotdsl.robotDsl.SensorDeclaration
import org.xtext.robotdsl.robotDsl.ActuatorDeclaration
import org.xtext.robotdsl.robotDsl.Rule
import org.xtext.robotdsl.robotDsl.Loop
import org.xtext.robotdsl.robotDsl.SimpleCondition
import org.xtext.robotdsl.robotDsl.CompositeCondition
import org.xtext.robotdsl.robotDsl.Action
import org.xtext.robotdsl.robotDsl.StateAction
import org.xtext.robotdsl.robotDsl.ParamAction

/**
 * Generates C++ and Webots world files from RobotDsl models.
 */
class RobotDslGenerator extends AbstractGenerator {
    
    override doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val model = resource.contents.head as Model
        val fileName = resource.URI.lastSegment.replace(".rbdsl", "")
        
        // Generate .cpp file
        fsa.generateFile(fileName + ".cpp", generateCppFile(model, fileName))
        
        // Generate .wbt file
        fsa.generateFile(fileName + ".wbt", generateWbtFile(model, fileName))
    }
    
    def generateCppFile(Model model, String fileName) '''
        #include <webots/Robot.hpp>
        #include <webots/DistanceSensor.hpp>
        #include <webots/LightSensor.hpp>
        #include <webots/TemperatureSensor.hpp>
        #include <webots/PressureSensor.hpp>
        #include <webots/Camera.hpp>
        #include <webots/PositionSensor.hpp>
        #include <webots/Accelerometer.hpp>
        #include <webots/Motor.hpp>
        #include <webots/LED.hpp>
        #include <cmath>
        #include <iostream>
        using namespace webots;
        using namespace std;
        
        int main(int argc, char **argv) {
            Robot *robot = new Robot();
            int timeStep = (int)robot->getBasicTimeStep();
            
            // Initialize sensors
            «FOR sensor : model.statements.filter(SensorDeclaration)»
                «generateSensorInitialization(sensor)»
            «ENDFOR»
            
            // Initialize actuators
            «FOR actuator : model.statements.filter(ActuatorDeclaration)»
                «generateActuatorInitialization(actuator, model)»
            «ENDFOR»
            
            // Main loop
            while (robot->step(timeStep) != -1) {
                // Read sensor values
                «FOR sensor : model.statements.filter(SensorDeclaration)»
                    «generateSensorValue(sensor)»
                «ENDFOR»
                
                // Execute statements
                «FOR statement : model.statements»
                    «generateStatement(statement)»
                «ENDFOR»
            }
            
            delete robot;
            return 0;
        }
    '''
    
    def generateSensorInitialization(SensorDeclaration sensor) '''
        «getSensorType(sensor.type.getLiteral)» *«sensor.name» = robot->get«getSensorType(sensor.type.getLiteral)»("«sensor.name»");
        «sensor.name»->enable(timeStep);
    '''
    
    def generateSensorValue(SensorDeclaration sensor) '''
        double «sensor.name»_value = 0.0;
        «IF sensor.type.getLiteral == "vibration"»
            const double *«sensor.name»_values = «sensor.name»->getValues();
            «sensor.name»_value = sqrt(«sensor.name»_values[0]*«sensor.name»_values[0] + «sensor.name»_values[1]*«sensor.name»_values[1] + «sensor.name»_values[2]*«sensor.name»_values[2]);
        «ELSEIF sensor.type.getLiteral == "color"»
            // Simplified: Use average intensity for camera
            «sensor.name»->enable(timeStep);
            const unsigned char *image = «sensor.name»->getImage();
            int width = «sensor.name»->getWidth();
            int height = «sensor.name»->getHeight();
            double sum = 0.0;
            for (int i = 0; i < width * height; i++) {
                sum += «sensor.name»->imageGetRed(image, width, i % width, i / width);
            }
            «sensor.name»_value = sum / (width * height);
        «ELSE»
            «sensor.name»_value = «sensor.name»->getValue();
        «ENDIF»
    '''
    
    def generateActuatorInitialization(ActuatorDeclaration actuator, Model model) '''
        «getActuatorType(actuator, model)» *«actuator.name» = robot->get«getActuatorType(actuator, model)»("«actuator.name»");
    '''
    
    def String getSensorType(String sensorType) {
        switch sensorType {
            case "distance": "DistanceSensor"
            case "light": "LightSensor"
            case "temperature": "TemperatureSensor"
            case "pressure": "PressureSensor"
            case "sound": "Microphone"
            case "color": "Camera"
            case "angle": "PositionSensor"
            case "humidity": "DistanceSensor" // Approximation
            case "vibration": "Accelerometer"
            default: "Sensor"
        }
    }
    
    def String getActuatorType(ActuatorDeclaration actuator, Model model) {
        // Check all actions to determine actuator type
        for (statement : model.statements) {
            if (statement instanceof Rule) {
                for (action : statement.actions) {
                    if (action.actuator == actuator) {
                        if (action instanceof ParamAction) {
                            switch action.parameter.getLiteral {
                                case "BRIGHTNESS": return "LED"
                                case "COLOR": return "LED"
                                case "SPEED": return "Motor"
                                case "DIRECTION": return "Motor"
                                case "ANGLE": return "Motor"
                                default: return "Motor"
                            }
                        } else if (action instanceof StateAction) {
                            return "LED" // StateAction (on/off) typically for LEDs
                        }
                    }
                }
            } else if (statement instanceof Loop) {
                for (nestedStmt : statement.statements) {
                    if (nestedStmt instanceof Rule) {
                        for (action : nestedStmt.actions) {
                            if (action.actuator == actuator) {
                                if (action instanceof ParamAction) {
                                    switch action.parameter.getLiteral {
                                        case "BRIGHTNESS": return "LED"
                                        case "COLOR": return "LED"
                                        case "SPEED": return "Motor"
                                        case "DIRECTION": return "Motor"
                                        case "ANGLE": return "Motor"
                                        default: return "Motor"
                                    }
                                } else if (action instanceof StateAction) {
                                    return "LED"
                                }
                            }
                        }
                    }
                }
            }
        }
        return "Motor" // Default to Motor
    }
    
    def dispatch String generateStatement(Rule rule) '''
        if («generateCondition(rule.condition)») {
            «FOR action : rule.actions»
                «generateAction(action)»
            «ENDFOR»
        }
    '''
    
    def dispatch String generateStatement(Loop loop) '''
        for (int i = 0; i < «loop.count»; i++) {
            «FOR statement : loop.statements»
                «generateStatement(statement)»
            «ENDFOR»
        }
    '''
    
    def dispatch String generateStatement(SensorDeclaration decl) '''
        // Sensor declaration handled in initialization
    '''
    
    def dispatch String generateStatement(ActuatorDeclaration decl) '''
        // Actuator declaration handled in initialization
    '''
    
    def dispatch String generateCondition(SimpleCondition cond) '''
        «cond.sensor.name»_value «cond.comparator.getLiteral» «cond.value»
    '''
    
    def dispatch String generateCondition(CompositeCondition cond) {
        if (cond.condition !== null) {
            '''!(«generateCondition(cond.condition)»)'''
        } else {
            '''(«generateCondition(cond.left)») «cond.op.toUpperCase» («generateCondition(cond.right)»)'''
        }
    }
    
    def dispatch String generateAction(StateAction action) '''
        «IF action.actuator !== null»
            «val actuatorName = action.actuator.name»
            «IF getActuatorType(action.actuator, action.eResource.contents.head as Model) == "LED"»
                «actuatorName»->set(«action.state.getLiteral == "on" ? "0xFF0000" : "0"»);
            «ELSE»
                «actuatorName»->setVelocity(«action.state.getLiteral == "on" ? "1.0" : "0.0"»);
            «ENDIF»
        «ELSE»
            // Null actuator, skip
        «ENDIF»
    '''
    
    def dispatch String generateAction(ParamAction action) '''
        «IF action.actuator !== null»
            «val actuatorName = action.actuator.name»
            «val param = action.parameter.getLiteral»
            «IF param == "SPEED"»
                «actuatorName»->setVelocity(«action.value / 1000.0»); // Convert to rad/s
            «ELSEIF param == "BRIGHTNESS"»
                «actuatorName»->set(«action.value / 100.0 * 0xFF»); // Scale to 0-255
            «ELSEIF param == "COLOR"»
                «actuatorName»->set(«action.value»); // Hex color
            «ELSEIF param == "DIRECTION" || param == "ANGLE"»
                «actuatorName»->setPosition(«action.value * 3.14159 / 180.0»); // Degrees to radians
            «ELSEIF param == "POWER"»
                «actuatorName»->setTorque(«action.value / 100.0»); // Scale power
            «ELSEIF param == "VOLUME" || param == "FREQUENCY" || param == "DURATION"»
                // Audio not supported in Webots, skip
                cout << "Warning: «param» not supported in Webots" << endl;
            «ELSE»
                «actuatorName»->set(«action.value»);
            «ENDIF»
        «ELSE»
            // Null actuator, skip
        «ENDIF»
    '''
    
    def generateWbtFile(Model model, String fileName) '''
        #VRML_SIM R2023b utf8
        WorldInfo {
            title "«fileName» Simulation"
        }
        Viewpoint {
            orientation 0 0 1 0
            position 0 0 10
        }
        RectangleArena {}
        Robot {
            name "«fileName»"
            controller "my_controller"
            translation 0 0 0.1
            children [
                Solid {
                    translation 0 0 0
                    children [
                        Shape {
                            geometry Box { size 0.2 0.2 0.2 }
                            appearance Appearance {
                                material Material { diffuseColor 0.8 0.8 0.8 }
                            }
                        }
                        «FOR sensor : model.statements.filter(SensorDeclaration)»
                            «generateSensorNode(sensor)»
                        «ENDFOR»
                        «FOR actuator : model.statements.filter(ActuatorDeclaration)»
                            «generateActuatorNode(actuator, model)»
                        «ENDFOR»
                    ]
                    boundingObject Box { size 0.2 0.2 0.2 }
                    physics Physics {}
                }
            ]
        }
        DEF FLOOR Solid {
            translation 0 0 -0.1
            children [
                Shape {
                    geometry Box { size 10 10 0.1 }
                    appearance Appearance {
                        material Material { diffuseColor 0.5 0.5 0.5 }
                    }
                ]
            ]
            boundingObject Box { size 10 10 0.1 }
            physics Physics {}
        }
    '''
    
    def generateSensorNode(SensorDeclaration sensor) '''
        «getSensorType(sensor.type.getLiteral)» {
            name "«sensor.name»"
            «IF sensor.type.getLiteral == "color"»
                resolution 64
            «ENDIF»
        }
    '''
    
    def generateActuatorNode(ActuatorDeclaration actuator, Model model) '''
        «IF getActuatorType(actuator, model) == "LED"»
            LED {
                name "«actuator.name»"
                color 1 0 0
            }
        «ELSE»
            HingeJoint {
                jointParameters HingeJointParameters {
                    axis 0 0 1
                }
                device [
                    RotationalMotor {
                        name "«actuator.name»"
                        maxVelocity 10
                    }
                ]
                endPoint Solid {
                    translation 0.1 0 0
                    children [
                        Shape {
                            geometry Cylinder { radius 0.05 height 0.1 }
                            appearance Appearance {
                                material Material { diffuseColor 0 0 1 }
                            }
                        }
                    ]
                    boundingObject Cylinder { radius 0.05 height 0.1 }
                    physics Physics {}
                }
            }
        «ENDIF»
    '''
}
/*
 * generated by Xtext 2.38.0
 */
package org.xtext.robotdsl.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.xtext.validation.Check;
import org.xtext.robotdsl.robotDsl.Action;
import org.xtext.robotdsl.robotDsl.ActuatorDeclaration;
import org.xtext.robotdsl.robotDsl.CompositeCondition;
import org.xtext.robotdsl.robotDsl.Condition;
import org.xtext.robotdsl.robotDsl.Declaration;
import org.xtext.robotdsl.robotDsl.Loop;
import org.xtext.robotdsl.robotDsl.Model;
import org.xtext.robotdsl.robotDsl.ParamAction;
import org.xtext.robotdsl.robotDsl.RobotDslPackage;
import org.xtext.robotdsl.robotDsl.Rule;
import org.xtext.robotdsl.robotDsl.SensorDeclaration;
import org.xtext.robotdsl.robotDsl.SimpleCondition;
import org.xtext.robotdsl.robotDsl.StateAction;

/**
 * Custom validation rules for the Robot DSL.
 */
public class RobotDslValidator extends AbstractRobotDslValidator {

    public static final String DUPLICATE_NAME = "duplicateName";
    public static final String UNDEFINED_REFERENCE = "undefinedReference";
    public static final String INVALID_SENSOR_USE = "invalidSensorUse";
    public static final String INVALID_ACTUATOR_USE = "invalidActuatorUse";
    public static final String INVALID_SENSOR_TYPE_VALUE = "invalidSensorTypeValue";
    public static final String CONFLICTING_ACTIONS = "conflictingActions";
    public static final String INVALID_COMPARATOR = "invalidComparator";
    public static final String EMPTY_CONDITION = "emptyCondition";
    public static final String INVALID_CONDITION = "invalidCondition";
    public static final String INVALID_PARAM_VALUE = "invalidParamValue";
    public static final String NEGATIVE_LOOP_COUNT = "negativeLoopCount";
    public static final String EXCESSIVE_LOOP_COUNT = "excessiveLoopCount";
    public static final String DECLARATION_IN_LOOP = "declarationInLoop";

    // Plages de valeurs valides pour les types de capteurs (aligned with SensorType enum)
    private static final Map<String, IntRange> SENSOR_VALUE_RANGES = new HashMap<>();
    static {
        SENSOR_VALUE_RANGES.put("distance", new IntRange(0, 1000)); // cm
        SENSOR_VALUE_RANGES.put("temperature", new IntRange(-50, 150)); // °C
        SENSOR_VALUE_RANGES.put("light", new IntRange(0, 1023)); // analogique
        SENSOR_VALUE_RANGES.put("pressure", new IntRange(0, 2000)); // kPa
        SENSOR_VALUE_RANGES.put("sound", new IntRange(0, 120)); // dB
        SENSOR_VALUE_RANGES.put("color", new IntRange(0, 16777215)); // RGB
        SENSOR_VALUE_RANGES.put("angle", new IntRange(0, 360)); // degrés
        SENSOR_VALUE_RANGES.put("humidity", new IntRange(0, 100)); // %
        SENSOR_VALUE_RANGES.put("vibration", new IntRange(0, 1023)); // analogique
    }

    // Comparateurs valides par type de capteur (aligned with Comparator enum)
    private static final Map<String, Set<String>> VALID_COMPARATORS = new HashMap<>();
    static {
        Set<String> rangeComparators = new HashSet<>();
        rangeComparators.add("<");
        rangeComparators.add("<=");
        rangeComparators.add(">");
        rangeComparators.add(">=");
        rangeComparators.add("==");
        rangeComparators.add("!=");
        VALID_COMPARATORS.put("distance", rangeComparators);
        VALID_COMPARATORS.put("temperature", rangeComparators);
        VALID_COMPARATORS.put("light", rangeComparators);
        VALID_COMPARATORS.put("pressure", rangeComparators);
        VALID_COMPARATORS.put("sound", rangeComparators);
        VALID_COMPARATORS.put("color", rangeComparators);
        VALID_COMPARATORS.put("angle", rangeComparators);
        VALID_COMPARATORS.put("humidity", rangeComparators);
        VALID_COMPARATORS.put("vibration", rangeComparators);
    }

    // Plages de valeurs pour les paramètres d'actionneurs (aligned with ActuatorParameterType enum)
    private static final Map<String, IntRange> PARAM_VALUE_RANGES = new HashMap<>();
    static {
        PARAM_VALUE_RANGES.put("SPEED", new IntRange(0, 255));
        PARAM_VALUE_RANGES.put("BRIGHTNESS", new IntRange(0, 100));
        PARAM_VALUE_RANGES.put("DIRECTION", new IntRange(0, 360));
        PARAM_VALUE_RANGES.put("VOLUME", new IntRange(0, 100));
        PARAM_VALUE_RANGES.put("FREQUENCY", new IntRange(20, 20000));
        PARAM_VALUE_RANGES.put("ANGLE", new IntRange(0, 180));
        PARAM_VALUE_RANGES.put("POWER", new IntRange(0, 100));
        PARAM_VALUE_RANGES.put("COLOR", new IntRange(0, 16777215));
        PARAM_VALUE_RANGES.put("DURATION", new IntRange(0, 10000));
    }

    // Classe utilitaire pour représenter une plage d'entiers
    private static class IntRange {
        private final int min;
        private final int max;

        public IntRange(int min, int max) {
            this.min = min;
            this.max = max;
        }

        public boolean contains(int value) {
            return value >= min && value <= max;
        }

        @Override
        public String toString() {
            return min + ".." + max;
        }
    }

    /**
     * Collecte les déclarations de capteurs et actionneurs.
     */
    private Map<String, ? extends Declaration>[] collectDeclarations(Model model) {
        Map<String, SensorDeclaration> sensorNames = new HashMap<>();
        Map<String, ActuatorDeclaration> actuatorNames = new HashMap<>();
        Set<String> seenNames = new HashSet<>();

        for (var stmt : model.getStatements()) {
            if (stmt instanceof Declaration decl) {
                String name = decl.getName();
                if (!seenNames.add(name)) {
                    warning("Nom dupliqué : '" + name + "' (type : " + 
                            (decl instanceof SensorDeclaration ? "capteur" : "actionneur") + "). Utilisez un nom unique.",
                            decl, RobotDslPackage.Literals.DECLARATION__NAME, DUPLICATE_NAME);
                }
                if (decl instanceof SensorDeclaration sensorDecl) {
                    sensorNames.put(name, sensorDecl);
                } else if (decl instanceof ActuatorDeclaration actuatorDecl) {
                    actuatorNames.put(name, actuatorDecl);
                }
            }
        }
        return new Map[]{sensorNames, actuatorNames};
    }

    /**
     * Vérifie que seuls les capteurs sont utilisés dans les conditions simples.
     */
    @Check
    public void checkSensorUsedInConditionOnly(SimpleCondition condition) {
        if (condition.getSensor() instanceof ActuatorDeclaration) {
            error("Un actionneur ne peut pas être utilisé comme capteur : '" + condition.getSensor().getName() + "'",
                  condition, RobotDslPackage.Literals.SIMPLE_CONDITION__SENSOR, INVALID_SENSOR_USE);
        }
    }

    /**
     * Vérifie récursivement que seules des déclarations de capteurs sont utilisées dans les conditions.
     */
    @Check
    public void checkSensorUsedInComplexCondition(Condition condition) {
        if (condition == null) {
            return;
        }
        if (condition instanceof SimpleCondition simpleCond) {
            checkSensorUsedInConditionOnly(simpleCond);
        } else if (condition instanceof CompositeCondition compCond) {
            if (compCond.getCondition() != null) {
                checkSensorUsedInComplexCondition(compCond.getCondition());
            } else if (compCond.getLeft() != null && compCond.getRight() != null) {
                checkSensorUsedInComplexCondition(compCond.getLeft());
                checkSensorUsedInComplexCondition(compCond.getRight());
            } else {
                error("Condition composite mal formée : sous-condition(s) manquante(s)",
                      compCond, null, INVALID_CONDITION);
            }
        }
    }

    /**
     * Vérifie que seuls les actionneurs sont utilisés dans les actions.
     */
    @Check
    public void checkActuatorUsedInActionOnly(Action action) {
        if (action.getActuator() instanceof SensorDeclaration) {
            error("Un capteur ne peut pas être utilisé comme actionneur : '" + action.getActuator().getName() + "'",
                  action, RobotDslPackage.Literals.ACTION__ACTUATOR, INVALID_ACTUATOR_USE);
        }
    }

    /**
     * Vérifie les références, types, comparateurs et conflits dans le modèle.
     */
    @Check
    public void checkReferencesAndTypes(Model model) {
        Map<String, ? extends Declaration>[] declarations = collectDeclarations(model);
        Map<String, SensorDeclaration> sensorNames = (Map<String, SensorDeclaration>) declarations[0];
        Map<String, ActuatorDeclaration> actuatorNames = (Map<String, ActuatorDeclaration>) declarations[1];

        for (var stmt : model.getStatements()) {
            if (stmt instanceof Rule rule) {
                if (rule.getCondition() == null) {
                    error("Une règle doit avoir une condition valide",
                          rule, RobotDslPackage.Literals.RULE__CONDITION, EMPTY_CONDITION);
                } else {
                    checkConditionReferencesAndTypes(rule.getCondition(), sensorNames);
                }
                checkActionConflicts(rule.getActions(), "règle");
                for (Action action : rule.getActions()) {
                    checkActionReferencesAndParams(action, actuatorNames);
                }
            } else if (stmt instanceof Loop loop) {
                checkLoopStatements(loop, sensorNames, actuatorNames);
            }
        }
    }

    /**
     * Vérifie les instructions dans une boucle.
     */
    private void checkLoopStatements(Loop loop, Map<String, SensorDeclaration> sensorNames, Map<String, ActuatorDeclaration> actuatorNames) {
        for (var stmt : loop.getStatements()) {
            if (stmt instanceof Declaration) {
                error("Les déclarations ne sont pas autorisées à l'intérieur d'une boucle",
                      stmt, RobotDslPackage.Literals.DECLARATION__NAME, DECLARATION_IN_LOOP);
            } else if (stmt instanceof Rule rule) {
                if (rule.getCondition() == null) {
                    error("Une règle doit avoir une condition valide",
                          rule, RobotDslPackage.Literals.RULE__CONDITION, EMPTY_CONDITION);
                } else {
                    checkConditionReferencesAndTypes(rule.getCondition(), sensorNames);
                }
                checkActionConflicts(rule.getActions(), "règle dans une boucle");
                for (Action action : rule.getActions()) {
                    checkActionReferencesAndParams(action, actuatorNames);
                }
            } else if (stmt instanceof Loop nestedLoop) {
                checkLoopStatements(nestedLoop, sensorNames, actuatorNames);
            }
        }
        if (loop.getCount() > 1000) {
            warning("Nombre d'itérations élevé (" + loop.getCount() + ") : risque de problèmes de performance.",
                    loop, RobotDslPackage.Literals.LOOP__COUNT, EXCESSIVE_LOOP_COUNT);
        }
    }

    /**
     * Vérifie les références, types et comparateurs dans les conditions.
     */
    private void checkConditionReferencesAndTypes(Condition condition, Map<String, SensorDeclaration> sensorNames) {
        if (condition == null) {
            return;
        }
        if (condition instanceof SimpleCondition simpleCond) {
            if (simpleCond.getSensor() == null || !sensorNames.containsKey(simpleCond.getSensor().getName())) {
                String availableSensors = String.join(", ", sensorNames.keySet());
                error("Capteur non défini : '" + (simpleCond.getSensor() != null ? simpleCond.getSensor().getName() : "null") + "'. Capteurs disponibles : " + (availableSensors.isEmpty() ? "aucun" : availableSensors),
                      simpleCond, RobotDslPackage.Literals.SIMPLE_CONDITION__SENSOR, UNDEFINED_REFERENCE);
            } else {
                String sensorType = simpleCond.getSensor().getType().getLiteral();
                IntRange range = SENSOR_VALUE_RANGES.get(sensorType);
                if (range != null && !range.contains(simpleCond.getValue())) {
                    error("Valeur " + simpleCond.getValue() + " hors plage pour le type '" + sensorType + "' (" + range + ")",
                          simpleCond, RobotDslPackage.Literals.SIMPLE_CONDITION__VALUE, INVALID_SENSOR_TYPE_VALUE);
                }
                Set<String> validComps = VALID_COMPARATORS.get(sensorType);
                if (validComps != null && !validComps.contains(simpleCond.getComparator().getLiteral())) {
                    error("Comparateur '" + simpleCond.getComparator().getLiteral() + "' non valide pour '" + sensorType + "'. Comparateurs valides : " + String.join(", ", validComps),
                          simpleCond, RobotDslPackage.Literals.SIMPLE_CONDITION__COMPARATOR, INVALID_COMPARATOR);
                }
            }
        } else if (condition instanceof CompositeCondition compCond) {
            if (compCond.getCondition() != null) {
                checkConditionReferencesAndTypes(compCond.getCondition(), sensorNames);
            } else if (compCond.getLeft() != null && compCond.getRight() != null) {
                checkConditionReferencesAndTypes(compCond.getLeft(), sensorNames);
                checkConditionReferencesAndTypes(compCond.getRight(), sensorNames);
            }
        }
    }

    /**
     * Vérifie les références et paramètres dans les actions.
     */
    private void checkActionReferencesAndParams(Action action, Map<String, ActuatorDeclaration> actuatorNames) {
        if (action.getActuator() == null || !actuatorNames.containsKey(action.getActuator().getName())) {
            String availableActuators = String.join(", ", actuatorNames.keySet());
            error("Actionneur non défini : '" + (action.getActuator() != null ? action.getActuator().getName() : "null") + "'. Actionneurs disponibles : " + (availableActuators.isEmpty() ? "aucun" : availableActuators),
                  action, RobotDslPackage.Literals.ACTION__ACTUATOR, UNDEFINED_REFERENCE);
        }
        if (action instanceof ParamAction paramAction) {
            String paramName = paramAction.getParameter().getLiteral();
            IntRange range = PARAM_VALUE_RANGES.get(paramName);
            if (range != null && !range.contains(paramAction.getValue())) {
                error("Valeur " + paramAction.getValue() + " hors plage pour le paramètre '" + paramName + "' (" + range + ")",
                      paramAction, RobotDslPackage.Literals.PARAM_ACTION__VALUE, INVALID_PARAM_VALUE);
            }
        }
    }

    /**
     * Vérifie les conflits d'actions dans une liste d'actions.
     */
    private void checkActionConflicts(List<Action> actions, String context) {
        Map<String, String> stateActions = new HashMap<>();
        Map<String, String> paramActions = new HashMap<>();
        List<String> conflicts = new ArrayList<>();

        for (Action action : actions) {
            String actuatorName = action.getActuator() != null ? action.getActuator().getName() : null;
            if (action instanceof StateAction stateAction) {
                String state = stateAction.getState().getLiteral();
                if (stateActions.containsKey(actuatorName) && !stateActions.get(actuatorName).equals(state)) {
                    String message = "Conflit dans " + context + " : l'actionneur '" + actuatorName +
                                     "' est défini à '" + stateActions.get(actuatorName) + "' et '" + state + "'";
                    conflicts.add(message);
                    warning(message, action, RobotDslPackage.Literals.ACTION__ACTUATOR, CONFLICTING_ACTIONS);
                }
                stateActions.put(actuatorName, state);
            } else if (action instanceof ParamAction paramAction) {
                String paramName = paramAction.getParameter().getLiteral();
                String paramKey = actuatorName != null ? actuatorName + "_" + paramName : null;
                if (paramKey != null && paramActions.containsKey(paramKey)) {
                    String message = "Conflit dans " + context + " : le paramètre '" + paramName +
                                     "' de l'actionneur '" + actuatorName + "' est défini plusieurs fois";
                    conflicts.add(message);
                    warning(message, paramAction, RobotDslPackage.Literals.PARAM_ACTION__PARAMETER, CONFLICTING_ACTIONS);
                }
                if (paramKey != null) {
                    paramActions.put(paramKey, paramName);
                }
            }
        }
    }

    /**
     * Vérifie que le compteur de la boucle est positif.
     */
    @Check
    public void checkLoopCount(Loop loop) {
        if (loop.getCount() <= 0) {
            error("Le nombre d'itérations de la boucle doit être positif",
                  loop, RobotDslPackage.Literals.LOOP__COUNT, NEGATIVE_LOOP_COUNT);
        }
    }
}